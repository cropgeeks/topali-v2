// (C) 2003-2005 Iain Milne
//
// This package may be distributed under the
// terms of the GNU General Public License (GPL)

package topali.cluster.dss;

import java.io.*;

import topali.data.*;

import pal.alignment.*;
import pal.datatype.*;
import pal.distance.*;
import pal.tree.*;
import pal.misc.*;
import pal.eval.*;
import pal.substmodel.*;

import topali.analyses.*;

public class DSS
{
	public static final int METHOD_JC = 1;
	public static final int METHOD_F84 = 2;	
	public static final int POWER_UNWEIGHTED = 1;
	public static final int POWER_WEIGHTED = 2;
	public static final int ONE_PASS = 1;
	public static final int TWO_PASS = 2;
	
	private SimpleAlignment win1, win2;
	private File wrkDir;
	private DSSResult result;
	
	public DSS(File wrkDir, DSSResult result, SimpleAlignment win1, SimpleAlignment win2)
	{
		this.wrkDir = wrkDir;
		this.result = result;
		this.win1 = win1;
		this.win2 = win2;
	}
	
	/*
	 * Calculates the DSS statistic.
	 */
	double calculate()
		throws Exception
	{
		// Calculate distances for the two windows
		DistanceMatrix dm1 = getDistance(win1, result.method);
		DistanceMatrix dm2 = getDistance(win2, result.method);
		
		// Scale (and multiply) each distance matrix
		scaleMulDistanceMatrix(dm1, result.avgDist / getAverageDistance(dm1));
		scaleMulDistanceMatrix(dm2, result.avgDist / getAverageDistance(dm2));
		
		// Scores for forward/backward		
		double dss_f = 0, dss_b = 0;
		
		dss_f = getFitchSumOfSquares(dm1, dm2);
		if (result.passCount == TWO_PASS)
			dss_b = getFitchSumOfSquares(dm2, dm1);
		
		// Use the forward or the backward score?
		double dss = (dss_f > dss_b) ? dss_f : dss_b;
		
		return dss;
	}
	
	private double getFitchSumOfSquares(DistanceMatrix dm1, DistanceMatrix dm2)
		throws Exception
	{
		Tree tree = new NeighborJoiningTree(dm1);
		
		RunFitch fitch = new RunFitch(result, false);
		fitch.getTree(wrkDir, tree, dm1);
		double ss1 = fitch.getSS();
		
		fitch = new RunFitch(result, true);
		fitch.getTree(wrkDir, tree, dm2);
		double ss12 = fitch.getSS();
		
		double ss = ss1 - ss12;
		if (ss < 0)
			ss *= -1;
		
		return ss;
	}

	private DistanceMatrix getDistance(SimpleAlignment window, int method)
	{
		switch (method)
		{
			case METHOD_JC:
				return TreeUtilities.getJukesCantorDistanceMatrix(window);
			
			case METHOD_F84:
			{
				return TreeUtilities.getMaximumLikelihoodDistanceMatrix(
					window, result.tRatio, result.alpha);
			}
			
			default:
				return null;
		}
	}
	
	/*
	 * Scales a DistanceMatrix by multiplying each element by the scaleBy value.
	 */
	private void scaleMulDistanceMatrix(DistanceMatrix dm, double scaleBy)
	{
		for (int i = 0; i < dm.getSize(); i++)
			for (int j = i; j < dm.getSize(); j++)
				dm.setDistance(i, j, (dm.getDistance(i, j) * scaleBy));
	}
	
	
	// Static helper methods
	
	/*
	 * Returns the average distance of the given SequenceSet alignment.
	 */
	public static double getAverageDistance(SequenceSet ss)
	{
		SimpleAlignment a = ss.getAlignment(true);
		JukesCantorDistanceMatrix dm = new JukesCantorDistanceMatrix(a);
		
		return getAverageDistance(dm);
	}
	
	/*
	 * Returns the average distance of the given DistanceMaxtix.
	 */
	public static double getAverageDistance(DistanceMatrix dm)
	{
		double sum = 0;
		for (int i = 0; i < dm.getSize(); i++)
			for (int j = i; j < dm.getSize(); j++)
				sum += dm.getDistance(i, j);
		
		// Return the average distance
		return sum /= ((dm.getSize() * dm.getSize()) / 2);
	}
}